<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HexagonGreed</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    .container {
      width: 100%;
      height: 100vh;
      position: relative;
    }

    canvas {
      /* width: 100%;
      height: 100%; */
    }

    .panel {
      position: fixed;
      right: 0;
      top: 0;
    }

    .panel {
      display: flex;
      flex-direction: column;
      padding: 1em;
      gap: 1em;
    }

    .clan-picker {
      background-color: aliceblue;
    }

    .city {
      display: flex;
      flex-direction: row;
      gap: 1em;
    }

    .city-list {
      max-height: 40vh;
      overflow: auto;
    }
  </style>
</head>

<body>
  <div class="container">
    <canvas></canvas>
    <div class="panel">
      <input type="color" />
      <select></select>
      <button id="getImage">Download Image</button>
    </div>
  </div>
  <script>

    Math.clamp = (v, min, max) => {
      return Math.min(Math.max(v, min), max)
    };

    Math.lerp = (a, b, t) => {
      return a + (b - a) * t
    };

    class Color {
      constructor(r = 0, g = 0, b = 0, a = 255) {
        this.r = r | 0
        this.g = g | 0
        this.b = b | 0
        this.a = a | 0
      }


      toHex() {
        function normalize(str) {
          if (str.length < 2) return `0${str}`
          return str
        }
        const r = normalize(this.r.toString(16))
        const g = normalize(this.g.toString(16))
        const b = normalize(this.b.toString(16))
        const a = normalize(this.a.toString(16))

        return `#${r}${g}${b}${a}`
      }

      static lerp(a, b, t) {
        const color = new Color(
          Math.lerp(a.r, b.r, t),
          Math.lerp(a.g, b.g, t),
          Math.lerp(a.b, b.b, t),
          Math.lerp(a.a, b.a, t),
        );
        return color;
      }

      static fromHex(str) {
        return new Color().fromHex(str)
      }
      fromHex(str) {
        str = str.replace("#", "")
        const vals = str.split(/(\w\w)/)
          .filter(v => v)
          .map(v => Number.parseInt(v, 16))

        this.r = vals[0] !== undefined ? vals[0] : this.r
        this.g = vals[1] !== undefined ? vals[1] : this.g
        this.b = vals[2] !== undefined ? vals[2] : this.b
        this.a = vals[3] !== undefined ? vals[3] : this.a

        return this
      }

      toTextColor() {
        const { r, g, b, a } = this
        const k = (r + g + b) / 3

        const j = 0.5
        let color = new Color()
        if (k >= 170) {
          // темнеее
          color = Color.lerp(new Color(r, g, b, a), new Color(0, 0, 0, 255), j)
        } else {
          // светлее
          color = Color.lerp(new Color(r, g, b, a), new Color(255, 255, 255, 255), j)
        }
        return color
      }

      static random() {
        const color = new Color()
        color.r = 30 + Math.random() * 225 | 0
        color.g = 30 + Math.random() * 225 | 0
        color.b = 30 + Math.random() * 225 | 0
        color.a = 160
        return color
      }
    }

    class Vector2 {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }

      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      }

      clone() {
        return new this.constructor(this.x, this.y);
      }

      sub(v) {
        return new Vector2(this.x - v.x, this.y - v.y)
      }

      add(v) {
        return new Vector2(this.x + v.x, this.y + v.y)
      }

      dot(v) {
        return this.x * v.x + this.y * v.y
      }

      copyFrom(v) {
        this.x = v.x
        this.y = v.y
      }

      static load(data) {
        return new Vector2(data.x, data.y)
      }
    }

    class BoundingBox {
      constructor() {
        this.min = null;
        this.max = null;
      }

      static load(data) {
        const box = new BoundingBox()
        data.min && (box.min = Vector2.load(data.min))
        data.min && (box.max = Vector2.load(data.max))
        return box
      }
      expand(p) {
        !this.min && (this.min = p.clone())
        !this.max && (this.max = p.clone())

        this.min.x > p.x && (this.min.x = p.x)
        this.max.x < p.x && (this.max.x = p.x)
        this.min.y > p.y && (this.min.y = p.y)
        this.max.y < p.y && (this.max.y = p.y)
      }

      contains(v) {
        return this.min && this.max && this.min.x < v.x && this.max.x > v.x &&
          this.min.y < v.y && this.max.y > v.y
      }

      redner(ctx) {
        if (this.min && this.max) {
          ctx.strokeRect(this.min.x, this.min.y, this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }

      getCenter() {
        return new Vector2(
          this.min.x + (this.max.x - this.min.x) / 2,
          this.min.y + (this.max.y - this.min.y) / 2,
        )
      }

    }


    class Hexagon {
      constructor(ctx, radius) {
        const R_r = 0.8660254037844386
        this.ctx = ctx
        this.radius = radius
        this.r = radius * R_r
      }

      drawGreed(x0 = 0, y0 = 0, width, height) {

        const { radius, r } = this

        for (let y = y0 + radius + r * 0.5, i = 0; y < height; y += radius + r / 2, i++) {
          for (let x = x0 + r * 2; x < width; x += r * 2) {
            this.draw(x + (i % 2 * r), y)
          }
        }

      }

      draw(x, y) {

        const { ctx, radius, r } = this

        ctx.moveTo(x, y + 1 * radius)
        ctx.lineTo(x + 1 * r, y + 0.5 * r)
        ctx.lineTo(x + 1 * r, y - 0.5 * r)
        ctx.lineTo(x, y - 1 * radius)
        ctx.lineTo(x - 1 * r, y - 0.5 * r)
        ctx.lineTo(x - 1 * r, y + 0.5 * r)
        ctx.lineTo(x, y + 1 * radius)
      }

      pointToHexagonCenter(mx, my) {

        const { radius, r } = this

        const dx = r * 2
        const dy = radius + r / 2
        const yCount = Math.round(my / dy)
        const x = (Math.round(mx / dx)) * dx - (yCount % 2 == 0 ? r : 0)
        const y = (yCount) * dy

        return { x, y }
      }
    }
    const cities = [
      { name: "Antinesia", points: [] },
      { name: "Ankara", points: [] },
      { name: "Mosuval", points: [] },
      { name: "Xerxes", points: [] },
      { name: "Baku", points: [] },
      { name: "Black Falvey", points: [] },
      { name: "Kandaharr", points: [] },
      { name: "Nanchou", points: [] },
      { name: "Lord Huo's", points: [] },
      { name: "Yumen", points: [] },
      { name: "Xiliang", points: [] },
      { name: "Rongzhou", points: [] },
      { name: "Jiequan", points: [] },
      { name: "Wuqiyan", points: [] },
      { name: "Qichen Valley", points: [] },
      { name: "Guirong City", points: [] },
      { name: "Mt Tianshe", points: [] },
      { name: "Ferry Yin Kou", points: [] },
      { name: "Xi Hai Camp", points: [] },
      { name: "Huangmo", points: [] },
      { name: "Ashkelon", points: [] },
      { name: "Arsuf", points: [] },
      { name: "New Acre", points: [] },
      { name: "Holy City", points: [] },
      { name: "Tikufah", points: [] },
      { name: "Petru", points: [] },
      { name: "Kerak", points: [] },
      { name: "Galilee", points: [] },
      { name: "Raynard's Death", points: [] },
      { name: "Charleston", points: [] },
      { name: "St. Pierre", points: [] },
      { name: "Tianyong", points: [] },
      { name: "Zhongzhou", points: [] },
      { name: "Lingyi", points: [] },
      { name: "Wuxiang", points: [] },
      { name: "Xiangcheng", points: [] },
      { name: "Yunmengze", points: [] },
      { name: "Qingbi", points: [] },
      { name: "Luoyang", points: [] },
      { name: "Qianyuang", points: [] },
      { name: "Qingliu", points: [] },
      { name: "Pingdong", points: [] },
      { name: "Liji", points: [] },
      { name: "Epang", points: [] },
      { name: "Yuncong", points: [] },
      { name: "Cangjian", points: [] },
      { name: "St. Orleans", points: [] },
      { name: "Stirling", points: [] },
      { name: "Sicilia", points: [] },
      { name: "Whire Rose", points: [] },
      { name: "Queen's Fort", points: [] },
    ]

    class ClanPicker {
      constructor(map) {
        this.map = map
        this.root = document.querySelector(".panel").appendChild(this.el("div"))
        this.render()
      }
      el(type) {
        return document.createElement(type)
      }

      render() {
        this.root.innerHTML = ""
        this.root.className = "clan-picker"

        this.name = this.root.appendChild(this.el("input"))
        this.name.placeholder = "ClanName"
        this.name.type = "text"
        this.root.appendChild(this.renderCities(this.map.cities))
      }

      renderCities(cities) {
        const root = this.el("div")
        const input = root.appendChild(this.el("input"))
        const list = root.appendChild(this.el("div"))
        list.className = "city-list"

        const render = (cities) => {
          console.log(input.value)
          list.innerHTML = ""
          cities.forEach(city => {
            const cityEl = list.appendChild(this.el("div"))
            cityEl.className = "city"
            const id = cityEl.appendChild(this.el("span"))
            id.innerText = city.id
            const name = cityEl.appendChild(this.el("span"))
            name.innerText = city.name
          })
        }

        input.onkeyup = ev => {
          const list = ev.target.value ?
            cities.filter(city => city.name.toLowerCase().indexOf(ev.target.value.toLowerCase()) !== -1) :
            cities
          render(list)
        }

        render(cities)
        return root
      }
    }

    class BosMap {
      constructor(imageUrl) {

        this.canvas = document.querySelector("canvas")
        this.ctx = this.canvas.getContext("2d")
        this.ctx.font = '50px serif';
        this.hexagon = new Hexagon(this.ctx, 20)
        this.showGrid = false
        this.editCities = false
        this.gridOffset = new Vector2(-5, 0)

        this.canvas.onmousemove = this.mouseMove
        this.canvas.onmousedown = this.mouseDown
        this.canvas.onclick = this.mouseClick
        document.onkeydown = this.keyDown

        this.load({ url: imageUrl, paths: [] })

        this.cities = cities.map(city => ({ ...city, color: Color.random().toHex() }))
        this.currentCity = 0

        this.clans = [
          {
            name: "ClanName",
            color: Color.random().toHex(),
            cities: [0, 1, 2]
          }
        ]

        this.getClansFromUrl()
      }

      getClansFromUrl() {

        function parseArgs(str) {
          console.log(str)
          const regex = /(\b\w+)\=\[color:(\w+),cities:([\d,]+)\]/gm;
          const result = []
          let m;

          while ((m = regex.exec(str)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
              regex.lastIndex++;
            }
            result.push({
              name: m[1],
              color: `#${m[2]}`,
              cities: m[3].split(",").map(v => Number(v))
            })
          }
          return result
        }
        const clans = parseArgs(document.location.search)
        this.clans = clans
      }

      drawClans(clans) {
        clans.forEach(clan => this.drawClan(clan))
      }

      drawText(p, text, color) {
        color && (this.ctx.fillStyle = color)
        this.ctx.font = '50px serif';
        let textInfo = this.ctx.measureText(text);
        this.ctx.fillText(text, p.x - textInfo.width * 0.5, p.y)
      }

      getCityCenter(city) {
        if (!city.bounding) {
          const boundingBox = new BoundingBox()
          city.points.forEach(({ x, y }) => boundingBox.expand(new Vector2(x, y)))
          city.bounding = boundingBox
        }
        return city.bounding.getCenter()
      }

      drawClan(clan) {
        const bounding = new BoundingBox()
        clan.cities.forEach(id => {
          const city = this.cities.find(city => city.id == id)
          if (city) {
            const color = Color.fromHex(clan.color)
            color.a = 100
            this.renderCity(city, color.toHex())
            const center = this.getCityCenter(city)
            bounding.expand(center)
          }
        })
        if (bounding.min && bounding.max) {
          const color = Color.fromHex(clan.color)
          color.a = 255

          this.drawText(bounding.getCenter(), clan.name, color.toTextColor().toHex())
        }
      }

      renderCity(city, color) {
        const points = city.points
        color = color || city.color || Color.random().toHex()
        this.ctx.strokeStyle = color
        this.ctx.fillStyle = color
        this.ctx.lineWidth = 1
        this.ctx.beginPath()
        for (let i = 0; i < points.length; i++) {
          const p = points[i]
          this.hexagon.draw(p.x, p.y)
        }
        this.ctx.closePath()
        this.ctx.fill()
        this.ctx.stroke()
      }

      renderCities() {
        this.cities.forEach(city => this.renderCity(city))
      }

      correctPoint(p) {
        const points = [];
        for (let i = 0; i < this.paths.length - 1; i++) {
          if (this.paths[i].contains(p)) {
            const closest = this.paths[i].closestPoint(p)
            const center = this.paths[i].getCenter()
            if (closest.distanceTo(center) > p.distanceTo(center)) {
              points.push(closest)
            }
          }
        }
        points
          .map(point => ({ point, dist: p.distanceTo(point) }))
          .sort((v1, v2) => v2.dist - v1.dist)

        return points[0] || p
      }

      toJSON() {
        return JSON.stringify({ paths: this.paths, url: this.url })
      }

      load(data) {
        this.url = data.url
        this.image = new Image(100, 100)
        this.imageLoaded = false;
        this.image.onload = () => {
          this.imageLoaded = true;
          this.resize()
          this.render()
        };

        this.image.src = this.url
        // this.paths = data.paths.map(path => PointsPath.load(path))
        // this.currentPath = new PointsPath()

      }
      resize() {
        const { clientWidth, clientHeight } = this.canvas
        this.canvas.width = this.image.naturalWidth;
        this.canvas.height = this.image.naturalHeight;
      }

      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
        this.ctx.drawImage(this.image, 0, 0);
        this.ctx.drawImage(this.image, 0, 0, this.image.width, this.image.height);

        if (this.showGrid) {
          this.ctx.beginPath()
          this.ctx.strokeStyle = "black"
          this.ctx.lineWidth = 1
          this.hexagon.drawGreed(this.gridOffset.x, this.gridOffset.y, this.canvas.width, this.canvas.height)
          this.ctx.closePath()
          this.ctx.stroke()
        }

        this.drawClans(this.clans)

        if (this.editCities) {
          this.renderCities()
        }
      }
      // pointToIndex(p) {
      //   return 0
      // }

      // indexToPoint(index) {
      //   return new Vector2(0, 0)
      // }

      mouseDown = ev => {
        // this.currentPath = new PointsPath()
        // this.paths.push(this.currentPath)
      }
      mouseClick = ev => {
        if (this.editCities) {
          const mousePoint = new Vector2(ev.offsetX, ev.offsetY)
          const p = this.hexagon.pointToHexagonCenter(mousePoint.x, mousePoint.y)
          const gridPoint = { x: p.x + this.gridOffset.x, y: p.y + this.gridOffset.y }
          this.cities[this.currentCity].points.push(gridPoint)
        }

        this.render()
      }

      lastPoint = null

      mouseMove = ev => {
        const mousePoint = new Vector2(ev.offsetX, ev.offsetY)

        if (this.editCities) {

          this.render()
          this.ctx.beginPath()
          this.ctx.strokeStyle = "salmon"
          this.ctx.lineWidth = 2
          const p = this.hexagon.pointToHexagonCenter(mousePoint.x, mousePoint.y)
          this.hexagon.draw(p.x - 5, p.y)
          this.ctx.closePath()
          this.ctx.stroke()
        }

      }

      keyDown = ev => {

        if (ev.key === "Escape") {
          if (this.editCities) {
            this.cities[this.currentCity].points.pop()
            this.render()
          }
        }
      }

      downloadImage() {
        this.canvas.toBlob(blob => {
          const a = document.createElement("a")
          const date = Intl.DateTimeFormat().format(new Date())
          a.download = `map_${date}.jpg`
          a.style.display = "none"
          a.href = URL.createObjectURL(blob)
          document.body.appendChild(a)
          a.click()
          a.remove()
        }, "image/jpeg", 0.7)
      }
    }
    const map = new BosMap("./map.png")
    map.render()

    fetch("./cities.json")
      .then(r => r.json())
      .then(cities => {
        map.cities = cities
        map.render()
      })
      .then(() => {
        const select = document.querySelector("select")
        map.cities.forEach((city, index) => {
          const option = document.createElement("option")
          option.value = index
          option.innerText = city.name
          select.appendChild(option)
        })
        select.onchange = ev => {
          map.currentCity = Number(ev.target.value)
        }
      })
      .then(() => {
        const clanPicker = new ClanPicker(map)
      })

    document.querySelector("#getImage").onclick = ev => {
      map.downloadImage()
    }


  </script>
</body>

</html>